/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package UI;

import Concretes.Ball;
import Concretes.Bricks.Brick;
import Concretes.Bricks.BrickGroup;
import Concretes.Direction;
import Concretes.GameObject;
import Concretes.Paddle;
import Concretes.PlayField;
import Enums.Edge;
import Interfaces.GameInterface;
import Interfaces.ScoreInterface;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.Timer;

/**
 *
 * @author IsaacCD
 */
public class GamePanel 
        extends javax.swing.JPanel
        implements GameInterface {

    public Timer clock = new Timer(17,new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            tick();
        }
        
    });
    
    private boolean showGameOver=false;
    
    public static final Dimension MINIMUM_SIZE = new Dimension(400,600);
    
    private PlayField playField;
    
    /**
     * Creates new form GamePanel
     */
    public GamePanel() {
        initComponents();
    }
    public void init(ScoreInterface scoreInterface) {
        super.setMinimumSize(MINIMUM_SIZE);
        super.setSize(MINIMUM_SIZE);
        playField = new PlayField(this,scoreInterface);
        clock.setInitialDelay(2000);
    }
    public void startGame() {
        if (playField!=null) {
            clock.start();
        }
    }
    public void tick() {
        this.repaint();
        playField.tick();
    }
    
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        
        if (playField!=null) {
            for (Ball ball:playField.getGameState().getBallArray()) {
                Rectangle bounds = ball.getBounds();
                Color color =ball.getColor();
                g.setColor(color);
                g.fillOval(bounds.x, bounds.y, bounds.width, bounds.height);
            }
            for (BrickGroup bricks:playField.getGameState().getBrickGroupArray()) {
                for (Brick brick:bricks.getBricks()) {
                    Rectangle bounds = brick.getBounds();
                    Color color =brick.getColor();
                    g.setColor(color);
                    g.fill3DRect(bounds.x, bounds.y, bounds.width, bounds.height,true);
                }
            }
            for (Paddle paddle:playField.getGameState().getPaddleArray()) {
                Rectangle bounds = paddle.getBounds();
                Color color = paddle.getColor();
                g.setColor(color);
                g.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
            }
            
            if (this.showGameOver) {
                Font font = new Font("TimesRoman", Font.PLAIN, 45);
                String text ="GAME OVER";
                Rectangle bg = new Rectangle(getWidth()/6,getHeight()/6,g.getFontMetrics(font).stringWidth(text),g.getFontMetrics(font).getHeight());
                
                g.setColor(Color.black);
                g.drawRect(bg.x, bg.y, bg.width, bg.height);
                
                bg=new Rectangle(bg.x+1,bg.y+1,bg.width-2,bg.height-2);
                g.setColor(Color.white);
                g.fillRect(bg.x, bg.y, bg.width, bg.height);
                
                g.setColor(Color.red);
                g.setFont(font);
                g.drawString(text,bg.x,bg.y+(bg.height-10));
            }
        }
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(java.awt.Color.green);
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        mouseTarget(evt.getLocationOnScreen());
    }//GEN-LAST:event_formMouseMoved

    @Override
    public Edge checkScreenEdgeIntersection(GameObject gameObject) {
        return playField.checkScreenEdgeIntersection(gameObject);
    }

    @Override
    public Direction checkBrickEdgeIntersection(Ball ball) {
        return playField.checkBrickEdgeIntersection(ball);
    }

    @Override
    public void mouseTarget(Point target) {
        playField.mouseTarget(target);
    }

    @Override
    public Direction checkPaddleEdgeIntersection(Ball ball) {
        return playField.checkPaddleEdgeIntersection(ball);
    }

    @Override
    public void pauseGame() {
        clock.stop();
        clock.start();
    }

    @Override
    public void showGameOver(boolean isVisible) {
        this.showGameOver=isVisible;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
